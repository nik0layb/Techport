# Стиль оформления PHP кода команды компании Techport.

#### Статья ниже является всего лишь напутствием автора (alias: "в кого можно кидаться помидорками"), сделанным исходя из личного мнения, основанного на технических требованиях к коду и требованиях сообщества программистов PHP, с которыми автор успел повидаться.

###### В кого можно кидаться помидорами: Харитонович Вадим, PHP-программист компании `Techport`.

>"Почти все убеждены, что любой стиль кроме их собственного ужасен и нечитаем. Уберите отсюда "кроме их собственного" — и они будут, наверное, правы... " Copyright Джерри Коффин (Jerry Coffin) об отступах

"Зачем мне следовать иному стилю кода, когда мой стиль очень такой симпатичный, да и демоны моральные и юридические меня не преследуют?" - прозрачно намекая, на этот вопрос пытается ответить цитата выше.

Если вам не понравился ответ цитаты, как человек, уже испытавший на себе разницу между двумя путями, я подготовил дополнительный.

####Кандидат №2:
- Кодстайл построен на стандартах, утвержденных сообществом [PHP-FIG](http://www.php-fig.org/), высококвалифицированных программистов, разрабатывающих такие фреймворки как: Laravel, Symphony, Phalcon, etc. Полный список принадлежности разработчиков к популярным проетам: http://www.php-fig.org/members/ 
- Повышение переносимости кода. Любой стандарт оформления кода на определенном языке следует тенденциям развития самого языка. Более того, общий стандарт позволяет программным путём заменить огромную часть старого кода на новый.
- Повышение удобочитаемости кода, как следствие: производительности других программистов. Стандарт проектируется сообществом состоящим из наиболее высококвалифицированных программистов на основе длительного опыта работы с кодом на конкретном языке и горячих ночных дискуссиях в борьбе за свой пробел после "if".
- Повышение тестируемости кода. Что связано с увеличением случаев выноса кода в отдельные функции, появлением нужной документации, комментариев, легкости, меньшей загрязненности.
- Повышение производительности кода. Реже, но и такое можно встретить. Сложнее незаметить ненужную переменную или выражение, потому что всё будет зафиксировано зрительно.

Если и этот ответ вас не заинтересовал, то вы попадаете в `default:` ветку, в которой мне нечем вам помочь.

##Об организации этого файла.
Большую часть статьи вы будете видеть текст, основанный на переводах 3 основных стандартов кода PHP:

1.  PSR-0. Стандарт автозагрузки. Важен при работе с автозагрузчиками классов, при написании своих автозагрузчиков, программ парсинга, анализа кода или использовании существующих.
2.  PSR-1. Базовый стандарт оформления кода. Основные аспекты, которые следует соблюдать.
3.  PSR-2. Рекомендации по оформлению кода. Хоть в названии и присутствует слово "рекомендации", фактически, они так же важны, как и PSR-1. Так как описывают наилучше практики оформления кода других программистов.

Есть дополнительное множество PSR стандартов, но так как их связь с кодстайлом практически не заметна, они будут забыты в этом документе.

> В случае, если текст использует цитату, она выделена данным образом.

Ссылки на EN, RU ресурсы, содержащие все стандарты в их первоначальном виде, вы найдёте в конце статьи в разделе "Ресурсы".
В качестве дополнения будут приведены вырезки кода.

Текст включает личные комментарии и идеи мои и тех заинтересованных, кто прочтет этот документ до конца.

    * Любая строка кодстайла может быть подвержена пересмотру по желанию команды Techport.

##[0] Терминология

* `нотация` - используется в контексте именования переменных. Подразумевает стиль, выбранный и используемый программистом в процессе именования новой переменной.
* `under_score` - нотация, которая определяет: каждое слово написано прописными буквами. Все слова разделены символом нижнего подчеркивания "\_" (ASCII: 0x5F).
* `SCREAMING_SNAKE_CASE` - нотация, которая определяет: каждое слово написано заглавными буквами. Все слова разделены символом нижнего подчеркивания "\_" (ASCII: 0x5F).
* `camelCase` - нотация, которая определяет: первое слово, начинается с прописной буквы. Каждое последующее слово начинается с заглавной буквы. Часть слова после первой буквы и до конца слова написана прописными буквами. Все слова написаны слитно.
* `StudlyCaps` - нотация, которая определяет: каждое слово начинается с заглавной буквы. Часть слова после первой буквы и до конца слова написана прописными буквами. Все слова написаны слитно.
* `класс` - подразумевает такие структуры данных, как: class, interface, trait.
* `helpers` - функции, обычно (но не обязательно) определяемые в глобальном пространстве имен, служащие для выполнения часто возникающих задач по обработке, фильтрации данных, выделению информации, etc. Их особенность в том, что их вызов не изменяет состояние программы, либо изменяет косвенным образом.

Пример хелпера:
```php
    /**
     * Extracts all elements divided by '/' character
     * from specified URI.
     *
     * @param string $uri
     * @return mixed $fragments
     */
    function fragmentURI($uri)
    {
        if (! is_string($uri)) {
            return false;
        }

        return ($uri = trim($uri, "/ \t\n\r\0\x0B")) ? explode('/', $uri) : false;
    }
```

##[0.5] Почти терминология
Файлы с кодом PHP PSR делит на две части: имеющие побочный эффект и не имеющие побочный эффект.
Побочный эффект - это эффект, который создает код, если после его интерпретации меняется состояние всего приложения. То есть, можно разграничить обработку кода на две части: его трансляция (с анализом синтаксиса, выделением памяти, всяческими оптимизациями) и интерпретация (совершения действий самим кодом, определенных программистом, после трансляции).

Есть побочный эффект:
```php
    // Подключение других файлов. 
    include 'SideEffect.php';

    // Вызов функций (здесь это __construct() и ниже).
    $se = new SideEffect();

    $se->printToScreen();           // Вывод на экран.
    $se->readFile();                // Запрашивание и использование системных ресурсов.
    $se->db->write('side effect');  // Записи в базу данных.

    // Многое другое, что производит какие-либо действия, 
    // способные изменить и/или изменяющие, состояние приложения.
```

Нет побочного эффекта:
```php
    namespace Vendor\NoSideEffect;
    
    use AnotherVendor\NoSideEffectExtended as ExtendedNoSE;
    
    // Определен класс, но его элементы не были задействованы в коде.
    class NSE 
    {
        public function nseMethod()
        {
            // Функция определена, но её вызова не было.
            echo "Hello!";
        }
    
        // Любой код не меняющий состояние приложения.
    }
```

С одной стороны это не относится к терминологии, с другой стороны, это выделено стандартом, как важное составляющее. В дальнейшем от этого и будем исходить.

##[1] Файлы
###[1][0] Организация

В файлах с расширением `.php` в качестве PHP-тэгов _разрешено_ использовать только ```<?php ?>``` - для обозначения PHP кода и ```<?= ?>``` - для сокращения команды вывода `echo`.
Если файл содержит только PHP код, не используйте закрывающий тэг ```?>```, это улучшит надёжность кода.

Используйте кодировку UTF-8 без BOM-байта.

В `.php` файлах _запрещено_ смешивать код __оказывающий__, __способный оказать {сейчас|в будущем}__ побочный эффект ```call_user_func('a');``` с кодом, __не оказывающим__ побочный эффект ```function a() { return; }```.

_РЕКОМЕНДУЕТСЯ_ использовать Unix-формат переноса строк (Unix linefeed, т.е. "\n" (ASCII: 0xA)).

> В конце каждого файла с PHP-кодом _ДОЛЖНА_ быть одна пустая строка.

###[1][1] Именование
Файлы нашего проекта легко делятся на два типа: с расширением `.php`, и без.

Файлы __без расширения__ ".php" именуются в свободном стиле.

Для __ВСЕХ ПРОЕКТНЫХ__ имен файлов:

* _ДОЛЖНЫ_  быть только на английском языке без использования транслитераций.
* _МОГУТ_   содержать символы следующего класса [a-zA-Z0-9_].
* _СЛЕДУЕТ_ уместить в 12 символов (вдруг еще существуют DOS-юзеры).
* _СЛЕДУЕТ_ содержать не больше 36 символов.

```bash
    # Получили строку вывода команды ls: 
    # -rw-r--r-- 1 wave wave 0 Sep 29 10:35 index.php
    wave@depth:~$ LSOUTPUT=$(ls -Al index.php)

    # Вывели длину этой строки.
    wave@depth:~$ echo ${#LSOUTPUT}
    47

    # 80:   ширина стандартного Unix Shell. 
    # 5 :   длина имени "index".
    # 3 :   средняя ширина колонки размера файла.
    80 - (47 - 5 - 1 + 3) = 36 
```

* _СЛЕДУЕТ_ давать имена простые для восприятия.

###С расширением .php

Содержащие в себе определение PHP класса, __без побочного эффекта__:

* _ДОЛЖНЫ_ быть написаны с использованием StudlyCaps.
* _ДОЛЖНЫ_ соответствовать названию класса, описанного в файле.

`Filename:      StudlyCapsClass.php
 File location: /home/wave/CodeStyle/StudlyCapsClass.php
`
```php
    class StudlyCapsClass
    {
        // Код.
    }
```

Не определяющие класс, __без побочного эффекта__ (например helpers):

* _ДОЛЖНЫ_ соответствовать under_score нотации.
* _ДОЛЖНЫ_ содержать область применения.

`
config.php:      Конфигурационный файл Phalcon
services.php:    Сервисы для Phalcon-контейнера.
`

* файлам типа "helpers" _СЛЕДУЕТ_ содержать в названии постфикс "\_helpers" для более быстрой ориентации среди файлов в under_score нотации.

`
sys_helpers.php:     Хелперы для работы с операционной системой.
http_helpers.php:    Хелперы для работы с HTTP протоколом.
`

__содержащие побочный эффект__:

* _ДОЛЖНЫ_  соответствовать under_score нотации.
* _МОГУТ_   содержать в названии контекст, в котором на приложение будет оказан побочный эффект. Прим.: index.php - файл индекса, инициализирующий приложение.

`Filename: index.php`
```php
    // Предположим существование класса инициализации нашего приложения.
    include 'Initializer.php';
    
    $init = new Initializer();
    
    $application = $init->create('http{s}://', 'techport.ru', [80, 443]);
    $application->start();
```

Имена, не вошедшие в одну из групп выше, считаются __НЕ СТАНДАРТНЫМИ__.

Предлагаю следующие требования для __НЕ СТАНДАРТНЫХ__ имен файлов:

* _ДОЛЖНЫ_  соответствовать SCREAMING_SNAKE_CASE нотации.
* _ДОЛЖНЫ_  содержать контекст, в котором применяется данный файл.

###[1][2] Пути

Для файлов __не определяющих__ PHP классов единого стандарта нет. 

Так как мы активно юзаем фреймворки в разработке, то:

* Требования разработчиков фреймворка _МОГУТ_ перекрывать общие стандарты. 
* Приоритет стандарта, диктуемого разработчиком фреймворка __ВСЕГДА ВЫШЕ__ общих стандартов разработки, за исключением отдельных случаев.
* Все конфликты наложения стандартов друг на друга мы разрешим.

Для каждого файла __определяющего__ один PHP класс:

Большинство современных фреймворков юзают автозагрузчики для подгрузки используемых классов. Для определения пути к файлу с классом функция, которая висит и ждет сигнала "тут нету класса с этим именем", должна как-либо получить полностью определенное пространство имен этого класса. Основываясь на пространстве имен, функция транслирует его в путь к файлу.

По дефолту, __стандартизированное пространство имен__ представляет следующую структуру: `\<разработчик>\<еще>\<несколько>\<пространств_имен>\<нужный_ресурс>`
Автозагрузчик транслирует пространство имен динамически/статически в путь к подгружаемому файлу класса: 
`Linux: <базовая_директория_автозагрузки>/<еще>/<несколько>/<пространств_имен>/<нужный_ресурс>.php`

__Основное требование__ к пути к файлу: его транслируемость в пространство имен, используемое кодом и наоборот.

К примеру мы будем юзать адаптер `MySQL`, базовая директория автозагрузки `/home/wave/Techport/CodeStyle`:
```php
    // Подключили.
    use Phalcon\Db\Adapter\MySQL;

    // Подгрузилось. 
    // Linux: /home/wave/Techport/CodeStyle/Phalcon/Db/Adapter/MySQL.php
    $adapter = new MySQL( 
        // args ...
    );
```

## [2] Код
### [2][0] Пространства имен

Полный путь к пространству имен _СЛЕДУЕТ_ начинать с пространства имён высшего уровня, указывающего на разработчика подгружаемого кода («имя производителя»).
```php
    // Ясно, что производитель: Phalcon
    use \Phalcon\Cache\Frontend\Output;
    use \Phalcon\Assets\Resource;   
```

Полный путь к пространству имен __может__ включать в себя любое количество вложенных пространств имен. Но __следует__ помнить об ограничениях файловых систем при интерпретации пространств имен в путь к файлу.
```php
    use \<some_vendor>\Db\<any>\<namespace>\Mysql;
```

Во время интерпретации пространств имен, разделители пространств имён преобразуется в разделитель имен каталогов соответствующей операционной системы.
```php    
    // Windows: <root_directory>\Phalcon\Db\Adapter\Mysql.php
    // Linux:   <root_directory>/Phalcon/Db/Adapter/Mysql.php
    use \Phalcon\Db\Adapter\Mysql;
```

Каждый символ "\_" (A) в имени класса (Class\_Name) преобразуется в разделитель имен каталогов. При этом названия пространств имен с этим же символом остаются неизменными.
```php
    // Windows: <root_directory>\Wave\Code_Style\RU\PHPLang.php
    // Linux:   <root_directory>/Wave/Code_Style/RU/PHPLang.php
    use \Wave\Code_Style\RU\PHP_Lang;
```

При обращении к файловой системе полностью определённое пространство имён и имя класса дополняются суффиксом _.php_. При использовании require, require_once стоит помнить, что не только имена файлов (Windows, Linux, OS X) могут включать точку (CodeStyle.php может оказаться директорией).


## Организация файла с кодом.

> Имена пространств имён и имена классов ДОЛЖНЫ следовать стандарту PSR-0. В конечном итоге это означает, что каждый класс должен располагаться в отдельном файле и в пространстве имён с хотя бы одним верхним уровнем (именем производителя).

> Имена классов ДОЛЖНЫ быть объявлены с использованием т.н. «StudlyCaps» (каждое слово начинается с большой буквы, между словами нет разделителей).

> Здесь под «классом» следует понимать также интерфейсы (interface) и примеси (trait).

```php
  namespace Wave\Document;

  use \Wave\ClassNames\StudlyCaps;
  use \Wave\RepeatNamespaces as Repeat;
  
  class CodeStyle extends Document implements Repeat
  {
      // code...
  }
```

> Константы классов ДОЛЖНЫ быть объявлены в верхнем регистре с использованием символа подчёркивания в качестве разделителя слов.

```php
  class Constants
  {
      const CONSTANT = 'ev4w';
      
      const ANOTHER_CONSTANT = 'tr0p';
  }
```

В именовании переменных используйте любой стиль: "camelCase", "StudlyCaps", "under_score" нотацию, но обязательно сохраняйте этот стиль.

> Какой бы вариант именования ни был выбран, СЛЕДУЕТ сохранять его неизменным в рамках некоторого разумного объёма кода (например, на уровне производителя, пакета, класса или метода).

Правило выше распространяется только на переменные, включая свойства классов. Имена методов классов и объектов объявляйте, используя "camelCase" нотацию.

```php
  class StudlyCaps
  {
      public function getNotation() 
      {
          // code...
      }
      
      public function setNotation() 
      {
          // code...
      }
  }
```

## Рекомендации по оформлению кода.

> Стилистические правила, представленные здесь, получены путём обобщения опыта различных проектов. Сотрудничество многих авторов из многих проектов позволяет выработать единый набор принципов и использовать его в этих проектах. Таким образом, польза представленных рекомендаций – не столько в самих рекомендациях, сколько в их распространении.



Старайтесь укладывать свой код в ширину от 80 до 120 символов. Это связано с шириной окон консольных оболочек (command.com, BASH), разрешением экранов мониторов, etc.

> Пустые строки МОГУТ быть добавлены в код для повышения удобочитаемости и разделения блоков кода.

> В одной строке НЕ ДОЛЖНО быть более одного выражения.

> Для оформления отступов ДОЛЖНЫ использоваться четыре пробела (но не знак табуляции).

> Примечание: использование только лишь пробелов (без смешивания их с табуляциями) позволяет избежать проблем с обработкой истории изменения кода, определением самих изменений, патчами и комментариями. Использование пробелов также позволяет легко добавлять небольшие отступы для выравнивания отдельных вложенных строк.

> Ключевые слова PHP ДОЛЖНЫ быть написаны в нижнем регистре.
Константы PHP true, false и null ДОЛЖНЫ быть написаны в нижнем регистре.

> В случае наличия определения пространства имён, после него ДОЛЖНА располагаться одна пустая строка.

Это позволяет не путаться между импортированными и определенными пространствами имен. Особенно в случае использования длинных пространств имен.

> В случае наличия импорта пространств имён, он ДОЛЖЕН располагаться после определения пространства имён.
При реализации импорта каждое пространство имён ДОЛЖНО импортироваться отдельно (со своим ключевым словом use).
После блока импорта ДОЛЖНА быть одна пустая строка.

```php
  namespace Wave\Document;

  use \Wave\ClassNames\StudlyCaps;
  use \Wave\RepeatNamespaces as Repeat;
  
  class ClassName
  {
      // code...
  }
```

> Ключевые слова extends и implements ДОЛЖНЫ находиться на той же строке, на которой находится имя класса.

> Открывающая фигурная скобка в определении класса ДОЛЖНА располагаться на новой строке, а закрывающая фигурная скобка ДОЛЖНА располагаться на следующей строке после тела класса.

```php
  class CodeStyle extends Document implements Repeat
  {
      // code...
  }
```

> Список реализуемых интерфейсов МОЖЕТ быть разделён на несколько строк, каждая из которых дополнена слева одним отступом (четырьмя пробелами). В таком случае первый элемент списка интерфейсов ДОЛЖЕН начинаться с новой строки, и в каждой строке ДОЛЖЕН быть указан только один интерфейс.

```php
  class CodeStyle extends Document implements 
      \Repeat
      \Wave\NextInterface
      \Port\AnotherInterface
  {
      // code...
  }
```

> Область видимости ДОЛЖНА быть явно указана для каждого свойства.

> При определении свойства НЕ ДОЛЖНО применяться ключевое слово var.

> В одном выражении НЕ ДОЛЖНО быть определено более одного свойства.

> Одиночный знак подчёркивания в начале имени свойства НЕ СЛЕДУЕТ использовать как признак защищённой (protected) или приватной (private) области видимости.

```php
  class CodeStyle
  {
      public $propertyOne;
      
      protected $_propertyTwo; # Нижнее подчеркивание не обязательно
  
      private $_propertyThree; # Нижнее подчеркивание не обязательно
      
      // code...
  }
```

Для каждого метода область видимости должна быть указана явно. Это позволяет избежать проблем с изменением правил интерпретации пустых полей области видимости при объявлении свойств и методов. 

> Одиночный знак подчёркивания в начале имени метода НЕ СЛЕДУЕТ использовать как признак защищённой (protected) или приватной (private) области видимости.

> После имени метода НЕ ДОЛЖНО быть пробела. Открывающая фигурная скобка ДОЛЖНА находиться на отдельной строке, а закрывающая фигурная скобка ДОЛЖНА находиться на следующей за телом метода строке. НЕ ДОЛЖНО быть пробелов после открывающей и перед закрывающей круглыми скобками в определении метода.

```php
namespace Vendor\Package;

class ClassName
{
    public function fooBarBaz($arg1, &$arg2, $arg3 = [])
    {
        // code...
    }
}
```

> В списке аргументов НЕ ДОЛЖНО быть пробела перед запятыми, но ДОЛЖЕН быть пробел после каждой запятой.
Аргументы со значениями по умолчанию ДОЛЖНЫ располагаться в конце списка (после аргументов без значений по умолчанию). { Примечание переводчика: и тут дело не в красоте, нарушение этого правила может привести ко вполне явным ошибкам выполнения программы, когда аргументу без значения по умолчанию «не хватит» значения при вызове метода.}

```php
  namespace Vendor\Package;
  
  class ClassName
  {
      public function foo($arg1, &$arg2, $arg3 = [])
      {
          // code...
      }
  }
```

> Список аргументов МОЖЕТ быть разделён на несколько строк, каждая из которых дополнена слева одним отступом (четырьмя пробелами). В таком случае первый элемент списка аргументов ДОЛЖЕН начинаться с новой строки, и в каждой строке ДОЛЖЕН быть указан только один аргумент.

> В случае, если список аргументов разделён на несколько строк, закрывающая круглая скобка и открывающая фигурная скобка ДОЛЖНЫ располагаться вместе на своей отдельной строке, а между ними должен быть один пробел.

```php
  namespace Vendor\Package;
  
  class ClassName
  {
      public function aVeryLongMethodName(
          ClassTypeHint $arg1,
          &$arg2,
          array $arg3 = []
      ) {
      // тело метода
      }
  }
```

> Ключевые слова abstract и final, в случае их наличия, ДОЛЖНЫ располагаться перед указанием области видимости.
> Ключевое слово static, в случае его наличия, ДОЛЖНО располагаться после указания области видимости.

```php
  namespace Vendor\Package;
  
  abstract class ClassName
  {
      protected static $foo;
      
      abstract protected function zim();
      
      final public static function bar()
      {
          // тело метода
      }
  }
```

> В коде вызова функций и методов НЕ ДОЛЖНО быть пробела между именем функции или метода и открывающей круглой скобкой, НЕ ДОЛЖНО быть пробела после открывающей круглой скобки, НЕ ДОЛЖНО быть пробела перед закрывающей круглой скобкой. В списке аргументов НЕ ДОЛЖНО быть пробелов перед запятыми, но ДОЛЖЕН быть пробел после каждой запятой.

```php
  bar();
  $foo->bar($arg1);
  Foo::bar($arg2, $arg3);
```

> Список аргументов МОЖЕТ быть разделён на несколько строк, каждая из которых дополнена слева одним отступом (четырьмя пробелами). В таком случае первый элемент списка аргументов ДОЛЖЕН начинаться с новой строки, и в каждой строке ДОЛЖЕН быть указан только один аргумент.

```php
  $foo->bar(
      $longArgument,
      $longerArgument,
      $muchLongerArgument
  );
```

> Общие правила оформления управляющих конструкций:

> После ключевого слова, определяющего управляющую конструкцию, ДОЛЖЕН быть один пробел.

> После открывающих круглых скобок НЕ ДОЛЖНО быть пробелов.

> Перед закрывающими круглыми скобками НЕ ДОЛЖНО быть пробелов.

> Между закрывающей круглой скобкой и открывающей фигурной скобкой ДОЛЖЕН быть один пробел.

> Тело конструкции ДОЛЖНО быть дополнено одним отступом (четырьмя пробелами).

> Закрывающая фигурная скобка ДОЛЖНА располагаться на следующей строке после тела конструкции.

> Тело каждой управляющей конструкции ДОЛЖНО быть заключено в фигурные скобки. Это позволяет стандартизировать внешний вид управляющих конструкций с снизить риск возникновения ошибок при добавлении новых строк в тело конструкции.

> Конструкция if выглядит следующим образом. Обратите внимание на круглые скобки, пробелы и фигурные скобки, а также на тот факт, что слова else и elseif располагаются в той же строке, что и закрывающая фигурная скобка предшествующего тела конструкции.

```php
  if ($expr1) {
      // code...
  } elseif ($expr2) {
      // code...
  } else {
      // code...
  }
```

> Ключевое слово elseif СЛЕДУЕТ использовать вместо отдельного сочетания else и if. Так конструкция будет представлять собой одно слово.

> Конструкция switch выглядит следующим образом. Обратите внимание на круглые скобки, пробелы и фигурные скобки. Выражение case ДОЛЖНО быть смещено на один отступ (четыре пробела) от switch, а ключевое слово break (или иное слово, обозначающее выход из конструкции) ДОЛЖНО располагаться на том же уровне отступов, что и тело case. В том случае, когда в непустом теле case умышленно не используется break, ДОЛЖЕН быть комментарий в стиле // no break.

```php
  switch ($expr) {
      case 0:
      echo 'First case, with a break';
      break;
      
      case 1:
      echo 'Second case, which falls through';
      // no break
      case 2:
      case 3:
      case 4:
      echo 'Third case, return instead of break';
      return;
      
      default:
      echo 'Default case';
      break;
  }
```

> Конструкция while выглядит следующим образом. Обратите внимание на круглые скобки, пробелы и фигурные скобки.

```php
  while ($expr) {
      // code...
  }
```

> Соответственно, конструкция do while выглядит следующим образом. Обратите внимание на круглые скобки, пробелы и фигурные скобки.

```php
  do {
      // code...
  } while ($expr);
```

> Конструкция for выглядит следующим образом. Обратите внимание на круглые скобки, пробелы и фигурные скобки.

```php
  for ($i = 0; $i < 10; $i++) {
      // code...
  }
```

> Конструкция foreach выглядит следующим образом. Обратите внимание на круглые скобки, пробелы и фигурные скобки.

```php
  foreach ($iterable as $key => $value) {
      // code...
  }
```

> Блоки конструкции try catch выглядят следующим образом. Обратите внимание на круглые скобки, пробелы и фигурные скобки.

```php
  try {
      // code...
  } catch (FirstExceptionType $e) {
      // code...
  } catch (OtherExceptionType $e) {
      // code...
  }
```

> Замыкания ДОЛЖНЫ описываться с использованием пробела после ключевого слова function и пробелами до и после ключевого слова use.

> Открывающая фигурная скобка ДОЛЖНА располагаться на одной строке с именем замыкания строке, а закрывающая фигурная скобка ДОЛЖНА располагаться на следующей строке после тела замыкания.
После открывающей круглой скобки и перед закрывающей круглой скобкой в списке аргументов или переменных НЕ ДОЛЖНО быть пробела.
В списке аргументов или переменных НЕ ДОЛЖНО быть пробелов перед запятыми, но ДОЛЖЕН быть один пробел после каждой запятой.
Аргументы замыкания со значениями по умолчанию ДОЛЖНЫ располагаться в конце списка (после аргументов без значений по умолчанию). {Примечание переводчика: и тут дело не в красоте, нарушение этого правила может привести ко вполне явным ошибкам выполнения программы, когда аргументу без значения по умолчанию «не хватит» значения при вызове.}

> Описание замыкания выглядит следующим образом. Обратите внимание на круглые скобки, запятые, пробелы и фигурные скобки.

```php
  $closureWithArgs = function ($arg1, $arg2) {
      // code...
  };
  
  $closureWithArgsAndVars = function ($arg1, $arg2) use ($var1, $var2) {
      // code...
  };
```

> Список аргументов и переменных МОЖЕТ быть разделён на несколько строк, каждая из которых дополнена слева одним отступом (четырьмя пробелами). В таком случае первый элемент списка ДОЛЖЕН начинаться с новой строки, и в каждой строке ДОЛЖЕН быть указан только один элемент.

> Когда последний список (аргументов или переменных) разделён на несколько строк, закрывающая круглая скобка и открывающая фигурная скобка ДОЛЖНЫ располагаться на одной строке и быть разделены одним пробелом.

> Ниже представлены примеры замыканий со списком аргументов и без него, а также со списком переменных, располагающимся на нескольких строках.

```php
  $longArgs_noVars = function (
      $longArgument,
      $longerArgument,
      $muchLongerArgument
  ) {
      // code...
  };
  
  $noArgs_longVars = function () use (
      $longVar1,
      $longerVar2,
      $muchLongerVar3
  ) {
      // code...
  };
  
  $longArgs_longVars = function (
      $longArgument,
      $longerArgument,
      $muchLongerArgument
  ) use (
      $longVar1,
      $longerVar2,
      $muchLongerVar3
  ) {
      // code...
  };
  
  $longArgs_shortVars = function (
      $longArgument,
      $longerArgument,
      $muchLongerArgument
  ) use ($var1) {
      // code...
  };
  
  $shortArgs_longVars = function ($arg) use (
      $longVar1,
      $longerVar2,
      $muchLongerVar3
  ) {
      // code...
  };
```

> Обратите внимание, что правила оформления замыканий также распространяются на случай, когда замыкание используется в качестве аргумента прямо в вызове функции или метода.

```php
  $foo->bar(
      $arg1,
      function ($arg2) use ($var1) {
          // code...
      },
      $arg3
  );
```
