# Стиль оформления PHP кода команды компании Techport.

#### Статья ниже является всего лишь напутствием автора (alias: "в кого можно кидаться помидорками"), сделанным исходя из личного мнения, основанного на технических требованиях к коду и требованиях сообщества программистов PHP, с которыми автор успел повидаться.

###### В кого можно кидаться помидорами: Харитонович Вадим, PHP-программист компании `Techport`.

>"Почти все убеждены, что любой стиль кроме их собственного ужасен и нечитаем. Уберите отсюда "кроме их собственного" — и они будут, наверное, правы... " Copyright Джерри Коффин (Jerry Coffin) об отступах

"Зачем мне следовать иному стилю кода, когда мой стиль очень такой симпатичный, да и демоны моральные и юридические меня не преследуют?" - прозрачно намекая, на этот вопрос пытается ответить цитата выше.

Если вам не понравился ответ цитаты, как человек, уже испытавший на себе разницу между двумя путями, я подготовил дополнительный.

####Кандидат №2:
- Кодстайл построен на стандартах, утвержденных сообществом [PHP-FIG](http://www.php-fig.org/), высококвалифицированных программистов, разрабатывающих такие фреймворки как: Symphony, Phalcon, Zend Framework 2, Magento, etc. Полный список принадлежности разработчиков к популярным проектам: http://www.php-fig.org/members/ 
- Повышение переносимости кода. Любой стандарт оформления кода на определенном языке следует тенденциям развития самого языка. Более того, общий стандарт позволяет программным путём заменить огромную часть старого кода на новый.
- Повышение удобочитаемости кода, как следствие: производительности других программистов. Стандарт проектируется сообществом состоящим из наиболее высококвалифицированных программистов на основе длительного опыта работы с кодом на конкретном языке и горячих ночных дискуссиях в борьбе за свой пробел после "if".
- Повышение тестируемости кода. Что связано с увеличением случаев выноса кода в отдельные функции, появлением нужной документации, комментариев, легкости, меньшей загрязненности.
- Повышение производительности кода. Реже, но и такое можно встретить. Сложнее незаметить ненужную переменную или выражение, потому что всё будет зафиксировано зрительно.

Если и этот ответ вас не заинтересовал, то вы попадаете в `default:` ветку, в которой мне нечем вам помочь.

##Об организации этого файла.
Большую часть статьи вы будете видеть текст, основанный на переводах 3 основных стандартов кода PHP:

1.  PSR-0. Стандарт автозагрузки. Важен при работе с автозагрузчиками классов, при написании своих автозагрузчиков, программ парсинга, анализа кода или использовании существующих.
2.  PSR-1. Базовый стандарт оформления кода. Основные аспекты, которые следует соблюдать.
3.  PSR-2. Рекомендации по оформлению кода. Хоть в названии и присутствует слово "рекомендации", фактически, они так же важны, как и PSR-1. Так как описывают наилучше практики оформления кода других программистов.

Есть дополнительное множество PSR стандартов, но так как их связь с кодстайлом практически не заметна, они будут забыты в этом документе.

> В случае, если текст использует цитату, она выделена данным образом.

Ссылки на EN, RU ресурсы, содержащие все стандарты в их первоначальном виде, вы найдёте в конце статьи в разделе "Ресурсы".
В качестве дополнения будут приведены вырезки кода.

Текст включает личные комментарии и идеи мои и тех заинтересованных, кто прочтет этот документ до конца.

    * Любая строка кодстайла может быть подвержена пересмотру по желанию команды Techport.

##[0] Терминология

* `нотация` - используется в контексте именования переменных. Подразумевает стиль, выбранный и используемый программистом в процессе именования новой переменной.
* `under_score` - нотация, которая определяет: каждое слово написано прописными буквами. Все слова разделены символом нижнего подчеркивания "\_" (ASCII: 0x5F).
* `SCREAMING_SNAKE_CASE` - нотация, которая определяет: каждое слово написано заглавными буквами. Все слова разделены символом нижнего подчеркивания "\_" (ASCII: 0x5F).
* `camelCase` - нотация, которая определяет: первое слово, начинается с прописной буквы. Каждое последующее слово начинается с заглавной буквы. Часть слова после первой буквы и до конца слова написана прописными буквами. Все слова написаны слитно.
* `StudlyCaps` - нотация, которая определяет: каждое слово начинается с заглавной буквы. Часть слова после первой буквы и до конца слова написана прописными буквами. Все слова написаны слитно.
* `класс` - подразумевает такие структуры данных, как: class, interface, trait.
* `helpers` - функции, обычно (но не обязательно) определяемые в глобальном пространстве имен, служащие для выполнения часто возникающих задач по обработке, фильтрации данных, выделению информации, etc. Их особенность в том, что их вызов не изменяет состояние программы, либо изменяет косвенным образом.

Пример хелпера:
```php
    /**
     * Extracts all elements divided by '/' character
     * from specified URI.
     *
     * @param string $uri
     * @return mixed $fragments
     */
    function fragmentURI($uri)
    {
        if (! is_string($uri)) {
            return false;
        }

        return ($uri = trim($uri, "/ \t\n\r\0\x0B")) ? explode('/', $uri) : false;
    }
```

##[0.5] Почти терминология
Файлы с кодом PHP PSR делит на две части: имеющие побочный эффект и не имеющие побочный эффект.
Побочный эффект - это эффект, который создает код, если после его интерпретации меняется состояние всего приложения. То есть, можно разграничить обработку кода на две части: его трансляция (с анализом синтаксиса, выделением памяти, всяческими оптимизациями) и интерпретация (совершения действий самим кодом, определенных программистом, после трансляции).

Есть побочный эффект:
```php
    // Подключение других файлов. 
    include 'SideEffect.php';

    // Вызов функций (здесь это __construct() и ниже).
    $se = new SideEffect();

    $se->printToScreen();           // Вывод на экран.
    $se->readFile();                // Запрашивание и использование системных ресурсов.
    $se->db->write('side effect');  // Записи в базу данных.

    // Многое другое, что производит какие-либо действия, 
    // способные изменить и/или изменяющие, состояние приложения.
```

Нет побочного эффекта:
```php
    namespace Vendor\NoSideEffect;
    
    use AnotherVendor\NoSideEffectExtended as ExtendedNoSE;
    
    // Определен класс, но его элементы не были задействованы в коде.
    class NSE 
    {
        public function nseMethod()
        {
            // Функция определена, но её вызова не было.
            echo "Hello!";
        }
    
        // Любой код не меняющий состояние приложения.
    }
```

С одной стороны это не относится к терминологии, с другой стороны, это выделено стандартом, как важное составляющее. В дальнейшем от этого и будем исходить.

##[1] Файлы
###[1][0] Организация

В файлах с расширением `.php` в качестве PHP-тэгов _разрешено_ использовать только ```<?php ?>``` - для обозначения PHP кода и ```<?= ?>``` - для сокращения команды вывода `echo`.

Если файл содержит только PHP код, не используйте закрывающий тэг ```?>```, это улучшит надёжность кода.

Используйте кодировку UTF-8 без BOM-байта.

В `.php` файлах _запрещено_ смешивать код __оказывающий__, __способный оказать {сейчас|в будущем}__ побочный эффект ```call_user_func('a');``` с кодом, __не оказывающим__ побочный эффект ```function a() { return; }```.

_РЕКОМЕНДУЕТСЯ_ использовать Unix-формат переноса строк (Unix linefeed, т.е. "\n" (ASCII: 0xA)).

> В конце каждого файла с PHP-кодом _ДОЛЖНА_ быть одна пустая строка.

###[1][1] Именование
Файлы нашего проекта легко делятся на два типа: с расширением `.php`, и без.

Файлы __без расширения__ `.php` именуются в свободном стиле.

Для __ВСЕХ ПРОЕКТНЫХ__ имен файлов:

* _ДОЛЖНЫ_  быть только на английском языке без использования транслитераций.
* _МОГУТ_   содержать символы соответствующие следующему набору: `[a-zA-Z0-9_]`.
* _СЛЕДУЕТ_ уместить в 12 символов (вдруг еще существуют DOS-юзеры).
* _СЛЕДУЕТ_ содержать не больше 36 символов.

```bash
    # Получили строку вывода команды ls: 
    # -rw-r--r-- 1 wave wave 0 Sep 29 10:35 index.php
    wave@depth:~$ LSOUTPUT=$(ls -Al index.php)

    # Вывели длину этой строки.
    wave@depth:~$ echo ${#LSOUTPUT}
    47

    # 80:   ширина стандартного Unix Shell. 
    # 5 :   длина имени "index".
    # 3 :   средняя ширина колонки размера файла.
    80 - (47 - 5 - 1 + 3) = 36 
```

* _СЛЕДУЕТ_ давать имена простые для восприятия.

###С расширением .php

Содержащие в себе определение PHP класса, __без побочного эффекта__:

> Имена пространств имён и имена классов _ДОЛЖНЫ_ следовать стандарту PSR-0. В конечном итоге это означает, что каждый класс должен располагаться в отдельном файле и в пространстве имён с хотя бы одним верхним уровнем (именем производителя).

* _ДОЛЖНЫ_ быть написаны с использованием StudlyCaps.
* _ДОЛЖНЫ_ соответствовать названию класса, описанного в файле.

```
Filename:      StudlyCapsClass.php
File location: /home/wave/CodeStyle/StudlyCapsClass.php
```
```php
    class StudlyCapsClass
    {
        // Код.
    }
```

Не определяющие класс, __без побочного эффекта__ (например helpers):

* _ДОЛЖНЫ_ соответствовать under_score нотации.
* _ДОЛЖНЫ_ содержать область применения.

```
config.php:      Конфигурационный файл Phalcon
services.php:    Сервисы для Phalcon-контейнера.
```

* файлам типа "helpers" _СЛЕДУЕТ_ содержать в названии постфикс "\_helpers" для более быстрой ориентации среди файлов в under_score нотации.

```
sys_helpers.php:     Хелперы для работы с операционной системой.
http_helpers.php:    Хелперы для работы с HTTP протоколом.
```

__Cодержащие побочный эффект__:

* _ДОЛЖНЫ_  соответствовать under_score нотации.
* _МОГУТ_   содержать в названии контекст, в котором на приложение будет оказан побочный эффект. Прим.: index.php - файл индекса, инициализирующий приложение.

```
Filename: index.php
```
```php
    // Предположим существование класса инициализации нашего приложения.
    include 'Initializer.php';
    
    $init = new Initializer();
    
    $application = $init->create('http{s}://', 'techport.ru', [80, 443]);
    $application->start();
```

Имена, не вошедшие в одну из групп выше, считаются __НЕ СТАНДАРТНЫМИ__.

Предлагаю следующие требования для __НЕ СТАНДАРТНЫХ__ имен файлов:

* _ДОЛЖНЫ_  соответствовать SCREAMING_SNAKE_CASE нотации.
* _ДОЛЖНЫ_  содержать контекст, в котором применяется данный файл.

###[1][2] Пути

Для файлов __не определяющих__ PHP классов единого стандарта нет. 

Так как мы активно юзаем фреймворки в разработке, то:

* Требования разработчиков фреймворка _МОГУТ_ перекрывать общие стандарты. 
* Приоритет стандарта, диктуемого разработчиком фреймворка __ВСЕГДА ВЫШЕ__ общих стандартов разработки, за исключением отдельных случаев.
* Все конфликты наложения стандартов друг на друга мы разрешим.

Для каждого файла __определяющего__ один PHP класс:

Большинство современных фреймворков юзают автозагрузчики для подгрузки используемых классов. Для определения пути к файлу с классом функция, которая висит и ждет сигнала "тут нету класса с этим именем", должна как-либо получить полностью определенное пространство имен этого класса. Основываясь на пространстве имен, функция транслирует его в путь к файлу.

По дефолту, __стандартизированное пространство имен__ представляет следующую структуру:

`\<разработчик>\<еще>\<несколько>\<пространств_имен>\<нужный_ресурс>`

Автозагрузчик транслирует пространство имен динамически/статически в путь к подгружаемому файлу класса:

`Linux: <базовая_директория_автозагрузки>/<еще>/<несколько>/<пространств_имен>/<нужный_ресурс>.php`

Требования:

* _ДОЛЖНЫ_ транслироваться из `namespace` в путь к файлу и обратно. Дополнительные требования к транслируемости указаны в п. [2][0].
* _СЛЕДУЕТ_ в файлах дирректорий использовать символы из соответствующие данному набору:`[a-zA-Z0-9_]`.

К примеру мы будем юзать адаптер `MySQL`, базовая директория автозагрузки `/home/wave/Techport/CodeStyle`:
```php
    // Подключили.
    use Phalcon\Db\Adapter\MySQL;

    // Подгрузилось. 
    // Linux: /home/wave/Techport/CodeStyle/Phalcon/Db/Adapter/MySQL.php
    $adapter = new MySQL( 
        // args ...
    );
```

##[2] Код
###[2][0] Общие рекомендации

Старайтесь укладывать свой код в ширину от 80 до 120 символов.

В одной строке _НЕ ДОЛЖНО_ быть более одного выражения.

```php
	// Плохо
	$variable_two = $variable_one ? $variable_three = $variable_one : $variable_two; 
	
	// Можно. Но проводится лишняя проверка и 1-2 лишних присвоения.
	$variable_two 	= $variable_one ?: $variable_two;
	$variable_three = $variable_one ?: $variable_three;
	
	// Хорошо
    if ($variable_one) {
        $variable_two   = $variable_one;
        $variable_three = $variable_two;
    }
```

Старайтесь включать в код пустые строки, если это способствует повышению удобочитаемости. Например, при разделении кода на логические блоки.

```php
    /**
	 * Checks, is remote user an our office user
	 * and returns true if it's true, otherwise - false.
	 *
	 * @return bool
	 */
	protected function isOffice()
	{
		$isOffice = self::$_isOfficeIPAddr;

		if (null !== $isOffice) {
			return $isOffice;
		}

		if ($clientIPA = $this->clientIP()) {
			$IPAddressList = $this->config['kloak']['filter'];

			if (is_string($IPAddressList)) {
				// Address list is nothing more than PCRE expression,
				// so - apply it to a remote address.
				$isOffice = preg_match($IPAddressList, $clientIPA);
			}
		}

		self::$_isOfficeIPAddr = $isOffice = (bool) $isOffice ?: false;

		return $isOffice;
	}
```

Для оформления отступов _СЛЕДУЕТ_ использовать четыре пробела, а не знак табуляции. Все существующие IDE позволяют настроить замену табуляции на соответствующее количество пробелов. 

Ключевые слова `true`, `false` и `null` _ДОЛЖНЫ_ быть написаны в нижнем регистре.

###[2][1] Пространства имен

Полный путь к пространству имен _СЛЕДУЕТ_ начинать с пространства имён высшего уровня, указывающего на разработчика подгружаемого кода («имя производителя»).
```php
    // Разработчик: wave
    namespace wave\Any\Develop;

    // Разработчик: Phalcon
    use \Phalcon\Cache\Frontend\Output;
    use \Phalcon\Assets\Resource;   
```

Полный путь к пространству имен __может__ включать в себя любое количество вложенных пространств имен. Но __следует__ помнить об ограничениях файловых систем при интерпретации пространств имен в путь к файлу.
```php
    namespace <some_vendor>\Db\<any>\<namespace>\Mysql;
```

Во время преобразования пространств имен, разделители пространств имён преобразуется в разделитель имен каталогов соответствующей операционной системы.
```php    
    namespace Phalcon\Db\Adapter\Mysql;
    
    // После преобразования:
    // Windows: <root_directory>\Phalcon\Db\Adapter\Mysql.php
    // Linux:   <root_directory>/Phalcon/Db/Adapter/Mysql.php
```

Каждый символ "\_" (ASCII: 0x5F) в имени класса (Class\_Name) преобразуется в разделитель имен каталогов. При этом названия пространств имен с этим же символом остаются неизменными.
```php
    namespace Wave\Code_Style\RU\PHP_Lang;
    
    // После преобразования:
    // Windows: <root_directory>\Wave\Code_Style\RU\PHPLang.php
    // Linux:   <root_directory>/Wave/Code_Style/RU/PHPLang.php
```

При обращении к файловой системе полностью определённый путь к пространству имён и имя класса дополняются суффиксом `.php`. При использовании `require`, `require_once` стоит помнить, что не только имена файлов (Windows, Linux, OS X) могут включать точку (CodeStyle.php может оказаться директорией).

Если файл определяет пространство имен, в котором выполняется его код, пространство имен _ДОЛЖНО_ быть указано в самом начале файла после тэгов `php`. 

Перед определением и после определения пространства имен _ДОЛЖНА_ идти одна строка.

```php
    <?php
    
    namespace wave\Document;
    
    // Код начинается здесь.
```

В случае, если файл __импортирует другие__ пространства имен:

* Импорт _ДОЛЖЕН_ начинаться после определения пространства имен (после `namespace ...`).
* Каждое импортируемое пространство имен _ДОЛЖНО_ быть указано на новой строке в виде: `use <пространство имен>;`.
* После каждого блока импорта _ДОЛЖНА_ быть одна пустая строка.

```php

    <?php
    
    namespace wave\Document;
    
    use \wave\ClassNames\StudlyCaps;
    use \wave\RepeatNamespaces as Repeat;

    use function \wave\Funcs\funcName;
    use function \wave\Funcs\anyOtherFunc;
    
    use const \wave\Constants\UNUSED;
    use const \wave\Constants\WANTED;

    class ClassName
    {
        // Код.
    }
```

###[2][2] Переменные

_ДОЛЖНЫ_ следовать одному из приведенных стилей именования: `camelCase`, `StudlyCaps`, `under_score`.

_ДОЛЖНЫ_ сохранять свой стиль именования на уровне обособленного участка кода, метода, класса, пакета, производителя, приложения.

_ДОЛЖНЫ_ сохранять стиль именования чужого кода. Если стиль именования чужого кода можно назвать __не стандартным__ (__не__ `camelCase`, `StudlyCaps`, `under_score`) вы _НЕ ДОЛЖНЫ_ следовать этому пункту на уровне кода этого производителя.

Имена переменных _НЕ ДОЛЖНЫ_ содержать транслитераций: `$transliteraciya = false;`.

###[2][3] Константы

Имя константы _ДОЛЖНО_ следовать стилю `SCREAMING_SNAKE_CASE`.

Имена констант _НЕ ДОЛЖНЫ_ содержать транслитераций: `const TRANSLITERACIYA = false;`.

###[2][3] Управляющие конструкции

> После ключевого слова, определяющего управляющую конструкцию, _ДОЛЖЕН_ быть один пробел.

> После открывающих круглых скобок _НЕ ДОЛЖНО_ быть пробелов.

> Перед закрывающими круглыми скобками _НЕ ДОЛЖНО_ быть пробелов.

> Между закрывающей круглой скобкой и открывающей фигурной скобкой _ДОЛЖЕН_ быть один пробел.

> Тело конструкции _ДОЛЖНО_ быть дополнено одним отступом (четырьмя пробелами).

> Закрывающая фигурная скобка _ДОЛЖНА_ располагаться на следующей строке после тела конструкции.

> Тело каждой управляющей конструкции ДОЛЖНО быть заключено в фигурные скобки. Это позволяет стандартизировать внешний вид управляющих конструкций и снизить риск возникновения ошибок при добавлении новых строк в тело конструкции.

> Конструкция if выглядит следующим образом. Обратите внимание на круглые скобки, пробелы и фигурные скобки, а также на тот факт, что слова else и elseif располагаются в той же строке, что и закрывающая фигурная скобка предшествующего тела конструкции.

```php
  if ($expr1) {
      // code...
  } elseif ($expr2) {
      // code...
  } else {
      // code...
  }
```

> Ключевое слово elseif _СЛЕДУЕТ_ использовать вместо отдельного сочетания else и if. Так конструкция будет представлять собой одно слово.

> Конструкция switch выглядит следующим образом. Обратите внимание на круглые скобки, пробелы и фигурные скобки. Выражение case _ДОЛЖНО_ быть смещено на один отступ (четыре пробела) от switch, а ключевое слово break (или иное слово, обозначающее выход из конструкции) _ДОЛЖНО_ располагаться на том же уровне отступов, что и тело case. В том случае, когда в непустом теле case умышленно не используется break, _ДОЛЖЕН_ быть комментарий в стиле // no break.

```php
  switch ($expr) {
      case 0:
      echo 'First case, with a break';
      break;
      
      case 1:
      echo 'Second case, which falls through';
      // no break
      case 2:
      case 3:
      case 4:
      echo 'Third case, return instead of break';
      return;
      
      default:
      echo 'Default case';
      break;
  }
```

> Конструкция while выглядит следующим образом. Обратите внимание на круглые скобки, пробелы и фигурные скобки.

```php
  while ($expr) {
      // code...
  }
```

> Соответственно, конструкция do while выглядит следующим образом. Обратите внимание на круглые скобки, пробелы и фигурные скобки.

```php
  do {
      // code...
  } while ($expr);
```

> Конструкция for выглядит следующим образом. Обратите внимание на круглые скобки, пробелы и фигурные скобки.

```php
  for ($i = 0; $i < 10; $i++) {
      // code...
  }
```

> Конструкция foreach выглядит следующим образом. Обратите внимание на круглые скобки, пробелы и фигурные скобки.

```php
  foreach ($iterable as $key => $value) {
      // code...
  }
```

> Блоки конструкции try catch выглядят следующим образом. Обратите внимание на круглые скобки, пробелы и фигурные скобки.

```php
  try {
      // code...
  } catch (FirstExceptionType $e) {
      // code...
  } catch (OtherExceptionType $e) {
      // code...
  }
```

## ___________________________Организация файла с кодом.



> Имена классов ДОЛЖНЫ быть объявлены с использованием т.н. «StudlyCaps» (каждое слово начинается с большой буквы, между словами нет разделителей).

> Здесь под «классом» следует понимать также интерфейсы (interface) и примеси (trait).

```php
  namespace Wave\Document;

  use \Wave\ClassNames\StudlyCaps;
  use \Wave\RepeatNamespaces as Repeat;
  
  class CodeStyle extends Document implements Repeat
  {
      // code...
  }
```

> Константы классов ДОЛЖНЫ быть объявлены в верхнем регистре с использованием символа подчёркивания в качестве разделителя слов.

```php
  class Constants
  {
      const CONSTANT = 'ev4w';
      
      const ANOTHER_CONSTANT = 'tr0p';
  }
```



Правило выше распространяется только на переменные, включая свойства классов. Имена методов классов и объектов объявляйте, используя "camelCase" нотацию.

```php
  class StudlyCaps
  {
      public function getNotation() 
      {
          // code...
      }
      
      public function setNotation() 
      {
          // code...
      }
  }
```

## Рекомендации по оформлению кода.







> Ключевые слова extends и implements ДОЛЖНЫ находиться на той же строке, на которой находится имя класса.

> Открывающая фигурная скобка в определении класса ДОЛЖНА располагаться на новой строке, а закрывающая фигурная скобка ДОЛЖНА располагаться на следующей строке после тела класса.

```php
  class CodeStyle extends Document implements Repeat
  {
      // code...
  }
```

> Список реализуемых интерфейсов МОЖЕТ быть разделён на несколько строк, каждая из которых дополнена слева одним отступом (четырьмя пробелами). В таком случае первый элемент списка интерфейсов ДОЛЖЕН начинаться с новой строки, и в каждой строке ДОЛЖЕН быть указан только один интерфейс.

```php
  class CodeStyle extends Document implements 
      \Repeat
      \Wave\NextInterface
      \Port\AnotherInterface
  {
      // code...
  }
```

> Область видимости ДОЛЖНА быть явно указана для каждого свойства.

> При определении свойства НЕ ДОЛЖНО применяться ключевое слово var.

> В одном выражении НЕ ДОЛЖНО быть определено более одного свойства.

> Одиночный знак подчёркивания в начале имени свойства НЕ СЛЕДУЕТ использовать как признак защищённой (protected) или приватной (private) области видимости.

```php
  class CodeStyle
  {
      public $propertyOne;
      
      protected $_propertyTwo; # Нижнее подчеркивание не обязательно
  
      private $_propertyThree; # Нижнее подчеркивание не обязательно
      
      // code...
  }
```

Для каждого метода область видимости должна быть указана явно. Это позволяет избежать проблем с изменением правил интерпретации пустых полей области видимости при объявлении свойств и методов. 

> Одиночный знак подчёркивания в начале имени метода НЕ СЛЕДУЕТ использовать как признак защищённой (protected) или приватной (private) области видимости.

> После имени метода НЕ ДОЛЖНО быть пробела. Открывающая фигурная скобка ДОЛЖНА находиться на отдельной строке, а закрывающая фигурная скобка ДОЛЖНА находиться на следующей за телом метода строке. НЕ ДОЛЖНО быть пробелов после открывающей и перед закрывающей круглыми скобками в определении метода.

```php
namespace Vendor\Package;

class ClassName
{
    public function fooBarBaz($arg1, &$arg2, $arg3 = [])
    {
        // code...
    }
}
```

> В списке аргументов НЕ ДОЛЖНО быть пробела перед запятыми, но ДОЛЖЕН быть пробел после каждой запятой.
Аргументы со значениями по умолчанию ДОЛЖНЫ располагаться в конце списка (после аргументов без значений по умолчанию). { Примечание переводчика: и тут дело не в красоте, нарушение этого правила может привести ко вполне явным ошибкам выполнения программы, когда аргументу без значения по умолчанию «не хватит» значения при вызове метода.}

```php
  namespace Vendor\Package;
  
  class ClassName
  {
      public function foo($arg1, &$arg2, $arg3 = [])
      {
          // code...
      }
  }
```

> Список аргументов МОЖЕТ быть разделён на несколько строк, каждая из которых дополнена слева одним отступом (четырьмя пробелами). В таком случае первый элемент списка аргументов ДОЛЖЕН начинаться с новой строки, и в каждой строке ДОЛЖЕН быть указан только один аргумент.

> В случае, если список аргументов разделён на несколько строк, закрывающая круглая скобка и открывающая фигурная скобка ДОЛЖНЫ располагаться вместе на своей отдельной строке, а между ними должен быть один пробел.

```php
  namespace Vendor\Package;
  
  class ClassName
  {
      public function aVeryLongMethodName(
          ClassTypeHint $arg1,
          &$arg2,
          array $arg3 = []
      ) {
      // тело метода
      }
  }
```

> Ключевые слова abstract и final, в случае их наличия, ДОЛЖНЫ располагаться перед указанием области видимости.
> Ключевое слово static, в случае его наличия, ДОЛЖНО располагаться после указания области видимости.

```php
  namespace Vendor\Package;
  
  abstract class ClassName
  {
      protected static $foo;
      
      abstract protected function zim();
      
      final public static function bar()
      {
          // тело метода
      }
  }
```

> В коде вызова функций и методов НЕ ДОЛЖНО быть пробела между именем функции или метода и открывающей круглой скобкой, НЕ ДОЛЖНО быть пробела после открывающей круглой скобки, НЕ ДОЛЖНО быть пробела перед закрывающей круглой скобкой. В списке аргументов НЕ ДОЛЖНО быть пробелов перед запятыми, но ДОЛЖЕН быть пробел после каждой запятой.

```php
  bar();
  $foo->bar($arg1);
  Foo::bar($arg2, $arg3);
```

> Список аргументов МОЖЕТ быть разделён на несколько строк, каждая из которых дополнена слева одним отступом (четырьмя пробелами). В таком случае первый элемент списка аргументов ДОЛЖЕН начинаться с новой строки, и в каждой строке ДОЛЖЕН быть указан только один аргумент.

```php
  $foo->bar(
      $longArgument,
      $longerArgument,
      $muchLongerArgument
  );
```



> Замыкания ДОЛЖНЫ описываться с использованием пробела после ключевого слова function и пробелами до и после ключевого слова use.

> Открывающая фигурная скобка ДОЛЖНА располагаться на одной строке с именем замыкания строке, а закрывающая фигурная скобка ДОЛЖНА располагаться на следующей строке после тела замыкания.
После открывающей круглой скобки и перед закрывающей круглой скобкой в списке аргументов или переменных НЕ ДОЛЖНО быть пробела.
В списке аргументов или переменных НЕ ДОЛЖНО быть пробелов перед запятыми, но ДОЛЖЕН быть один пробел после каждой запятой.
Аргументы замыкания со значениями по умолчанию ДОЛЖНЫ располагаться в конце списка (после аргументов без значений по умолчанию). {Примечание переводчика: и тут дело не в красоте, нарушение этого правила может привести ко вполне явным ошибкам выполнения программы, когда аргументу без значения по умолчанию «не хватит» значения при вызове.}

> Описание замыкания выглядит следующим образом. Обратите внимание на круглые скобки, запятые, пробелы и фигурные скобки.

```php
  $closureWithArgs = function ($arg1, $arg2) {
      // code...
  };
  
  $closureWithArgsAndVars = function ($arg1, $arg2) use ($var1, $var2) {
      // code...
  };
```

> Список аргументов и переменных МОЖЕТ быть разделён на несколько строк, каждая из которых дополнена слева одним отступом (четырьмя пробелами). В таком случае первый элемент списка ДОЛЖЕН начинаться с новой строки, и в каждой строке ДОЛЖЕН быть указан только один элемент.

> Когда последний список (аргументов или переменных) разделён на несколько строк, закрывающая круглая скобка и открывающая фигурная скобка ДОЛЖНЫ располагаться на одной строке и быть разделены одним пробелом.

> Ниже представлены примеры замыканий со списком аргументов и без него, а также со списком переменных, располагающимся на нескольких строках.

```php
  $longArgs_noVars = function (
      $longArgument,
      $longerArgument,
      $muchLongerArgument
  ) {
      // code...
  };
  
  $noArgs_longVars = function () use (
      $longVar1,
      $longerVar2,
      $muchLongerVar3
  ) {
      // code...
  };
  
  $longArgs_longVars = function (
      $longArgument,
      $longerArgument,
      $muchLongerArgument
  ) use (
      $longVar1,
      $longerVar2,
      $muchLongerVar3
  ) {
      // code...
  };
  
  $longArgs_shortVars = function (
      $longArgument,
      $longerArgument,
      $muchLongerArgument
  ) use ($var1) {
      // code...
  };
  
  $shortArgs_longVars = function ($arg) use (
      $longVar1,
      $longerVar2,
      $muchLongerVar3
  ) {
      // code...
  };
```

> Обратите внимание, что правила оформления замыканий также распространяются на случай, когда замыкание используется в качестве аргумента прямо в вызове функции или метода.

```php
  $foo->bar(
      $arg1,
      function ($arg2) use ($var1) {
          // code...
      },
      $arg3
  );
```
