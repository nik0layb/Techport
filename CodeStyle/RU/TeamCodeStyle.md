# Стиль оформления PHP кода команды компании Techport.

#### Статья ниже является всего лишь напутствием автора (alias: "в кого можно кидаться помидорками"), сделанным исходя из личного мнения, основанного на технических требованиях к коду и требованиях сообщества программистов PHP, с которыми автор успел повидаться.

###### В кого можно кидаться помидорами: Харитонович Вадим, PHP-программист компании `Techport`.

>"Почти все убеждены, что любой стиль кроме их собственного ужасен и нечитаем. Уберите отсюда "кроме их собственного" — и они будут, наверное, правы... " Copyright Джерри Коффин (Jerry Coffin) об отступах

"Зачем мне следовать иному стилю кода, когда мой стиль очень такой симпатичный, да и демоны моральные и юридические меня не преследуют?" - прозрачно намекая, на этот вопрос пытается ответить цитата выше.

Если вам не понравился ответ цитаты, как человек, уже испытавший на себе разницу между двумя путями, я подготовил дополнительный.

####Кандидат №2:
- Кодстайл построен на стандартах, утвержденных сообществом [PHP-FIG](http://www.php-fig.org/), высококвалифицированных программистов, разрабатывающих такие продукты, как: Symphony, Phalcon, Zend Framework 2, Magento, etc. Полный список принадлежности разработчиков к популярным проектам: http://www.php-fig.org/members/ 
- Повышение переносимости кода. Любой стандарт оформления кода на определенном языке следует тенденциям развития самого языка. Более того, общий стандарт позволяет программным путём куда быстрее переводить код предназначенный для старой версии на новый синтаксис языка новой версии.
- Повышение удобочитаемости кода, как следствие: производительности других программистов. Стандарт проектируется сообществом на основе длительного опыта работы с кодом и горячих ночных дискуссиях в борьбе за свой пробел после "if".
- Повышение тестируемости кода. Что связано с увеличением случаев выноса кода в отдельные функции, появлением нужной документации, комментариев, легкости, меньшей загрязненности.
- Повышение производительности кода. Реже. Например, сложнее незаметить ненужную переменную или выражение, потому что всё будет зафиксировано зрительно.

Если и этот ответ вас не заинтересовал, то вы попадаете в `default:` ветку, в которой мне нечем вам помочь.

##Об организации этого файла.
Большую часть статьи вы будете видеть текст, основанный на переводах 3 основных стандартов кода PHP:

1.  PSR-{0|4}. Стандарт автозагрузки. Важен при работе с автозагрузчиками классов, при написании своих автозагрузчиков, программ парсинга, анализа кода или использовании существующих.
2.  PSR-1. Базовый стандарт оформления кода. Основные аспекты, которые следует соблюдать.
3.  PSR-2. Рекомендации по оформлению кода. Хоть в названии и присутствует слово "рекомендации", фактически, они так же важны, как и PSR-1, так как описывают наилучше практики оформления кода других программистов.

Есть дополнительное множество PSR стандартов, но так как их связь с кодстайлом практически не заметна, они будут забыты в этом документе.

> В случае, если текст использует цитату, она выделена данным образом.

Ссылки на EN, RU ресурсы, содержащие все стандарты и их переводы в их первоначальном виде, вы найдёте в конце статьи в разделе _"Ресурсы"_.
В качестве дополнения будут приведены вырезки кода.

Текст включает личные комментарии и идеи мои и тех заинтересованных, кто прочтет этот документ до конца.

    * Любая строка кодстайла может быть подвержена пересмотру по желанию команды Techport.

##[0] Терминология

* `нотация` - используется в контексте именования переменных. Подразумевает стиль, выбранный и используемый программистом в процессе именования новой переменной.
* `under_score` - нотация, которая определяет: каждое слово написано прописными буквами. Все слова разделены символом нижнего подчеркивания "\_" (ASCII: 0x5F).
* `SCREAMING_SNAKE_CASE` - нотация, которая определяет: каждое слово написано заглавными буквами. Все слова разделены символом нижнего подчеркивания "\_" (ASCII: 0x5F).
* `camelCase` - нотация, которая определяет: первое слово, начинается с прописной буквы. Каждое последующее слово начинается с заглавной буквы. Часть слова после первой буквы и до конца слова написана прописными буквами. Все слова написаны слитно.
* `StudlyCaps` - нотация, которая определяет: каждое слово начинается с заглавной буквы. Часть слова после первой буквы и до конца слова написана прописными буквами. Все слова написаны слитно.
* `класс` - подразумевает такие структуры данных, как: class, interface, trait.
* `helpers` - функции, обычно (но не обязательно) определяемые в глобальном пространстве имен, служащие для выполнения часто возникающих задач по обработке, фильтрации данных, выделению информации, etc. Их особенность в том, что их вызов не изменяет состояние программы, либо изменяет косвенным образом.

Пример хелпера:
```php
    /**
     * Extracts all elements divided by '/' character
     * from specified URI.
     *
     * @param string $uri
     * @return mixed $fragments
     */
    function fragmentURI($uri)
    {
        if (! is_string($uri)) {
            return false;
        }

        return ($uri = trim($uri, "/ \t\n\r\0\x0B")) ? explode('/', $uri) : false;
    }
```

###[0][0] Почти терминология
Файлы с кодом PHP PSR делит на две части: имеющие побочный эффект и не имеющие побочный эффект.
Побочный эффект - это эффект, который создает код, если после его интерпретации меняется состояние всего приложения. То есть, можно разграничить обработку кода на две части: его трансляция (с анализом синтаксиса, выделением памяти, всяческими оптимизациями) и интерпретация (совершения действий самим кодом, определенных программистом, после трансляции).

Есть побочный эффект:
```php
    // Подключение других файлов. 
    include 'SideEffect.php';

    // Вызов функций/методов (здесь это __construct() и ниже).
    $se = new SideEffect();

    $se->printToScreen();           // Вывод на экран.
    $se->readFile();                // Запрашивание и использование системных ресурсов.
    $se->db->write('side effect');  // Записи в базу данных.

    // Многое другое, что производит какие-либо действия, 
    // способные изменить и/или изменяющие, состояние приложения.
```

Нет побочного эффекта:
```php
    namespace Vendor\NoSideEffect;
    
    use AnotherVendor\NoSideEffectExtended as ExtendedNoSE;
    
    // Определен класс, но его элементы не были задействованы в коде.
    class NSE extends ExtendedNoSE
    {
        public function nseMethod()
        {
            // Функция определена, но её вызова не было.
            echo "Hello!";
        }
    
        // Любой код не меняющий состояние приложения.
    }
```

С одной стороны это не относится к терминологии, с другой стороны, это выделено стандартом, как важное составляющее. В дальнейшем от этого и будем исходить.

##[1] Файлы
###[1][0] Организация

В файлах с расширением `.php` в качестве PHP-тэгов _СЛЕДУЕТ_ использовать только ```<?php ?>``` - для обозначения PHP кода и ```<?= ?>``` - для сокращения команды вывода `echo`.

Если файл содержит только PHP код, не используйте закрывающий тэг ```?>```, это улучшит надёжность кода.

Используйте кодировку UTF-8 без BOM-байта.

В `.php` файлах _ЗАПРЕЩЕНО_ смешивать код __оказывающий__, __способный оказать {сейчас|в будущем}__ побочный эффект ```call_user_func('a');``` с кодом, __не оказывающим__ побочный эффект ```function a() { return; }```.

_РЕКОМЕНДУЕТСЯ_ использовать Unix-формат переноса строк (Unix linefeed, т.е. "\n" (ASCII: 0xA)).

> В конце каждого файла с PHP-кодом _ДОЛЖНА_ быть одна пустая строка.

###[1][1] Именование
Файлы нашего проекта легко делятся на два типа: с расширением `.php`, и без.

Файлы __без расширения__ `.php` именуются в свободном стиле.

Для __ВСЕХ ПРОЕКТНЫХ__ имен файлов:

* _ДОЛЖНЫ_  быть только на английском языке без использования транслитераций.
* _МОГУТ_   содержать символы соответствующие следующему набору: `[a-zA-Z0-9_]`.
* _СЛЕДУЕТ_ уместить в 12 символов (вдруг еще существуют DOS-юзеры).
* _СЛЕДУЕТ_ содержать не больше 36 символов.

```bash
    # Получили строку вывода команды ls: 
    # -rw-r--r-- 1 wave wave 0 Sep 29 10:35 index.php
    wave@depth:~$ LSOUTPUT=$(ls -Al index.php)

    # Вывели длину этой строки.
    wave@depth:~$ echo ${#LSOUTPUT}
    47

    # 80:   ширина стандартного Unix Shell. 
    # 5 :   длина имени "index".
    # 3 :   средняя ширина колонки размера файла.
    80 - (47 - 5 - 1 + 3) = 36 
```

* _СЛЕДУЕТ_ давать имена простые для восприятия и прочтения.

###С расширением .php

Определяющие PHP класс, __без побочного эффекта__:

> Имена пространств имён и имена классов _ДОЛЖНЫ_ следовать стандарту PSR-0. В конечном итоге это означает, что каждый класс должен располагаться в отдельном файле и в пространстве имён с хотя бы одним верхним уровнем (именем производителя).

* _ДОЛЖНЫ_ быть написаны с использованием StudlyCaps.
* _ДОЛЖНЫ_ соответствовать названию класса, описанного в файле.

```
Filename:      StudlyCapsClass.php
File location: /home/wave/CodeStyle/StudlyCapsClass.php
```
```php
    class StudlyCapsClass
    {
        // Код.
    }
```

Не определяющие PHP класс, __без побочного эффекта__ (например helpers):

* _ДОЛЖНЫ_ соответствовать under_score нотации.
* _ДОЛЖНЫ_ содержать область применения.

```
config.php		- конфигурационный файл Phalcon
services.php	- сервисы для Phalcon-контейнера.
```

* файлам типа `helpers` _СЛЕДУЕТ_ содержать в названии постфикс "\_helpers" для более быстрой ориентации среди файлов в `under_score` нотации.

```
sys_helpers.php		- хелперы для работы с операционной системой.
http_helpers.php	- хелперы для работы с HTTP протоколом.
```

__Cодержащие побочный эффект__:

* _ДОЛЖНЫ_  соответствовать under_score нотации.
* _МОГУТ_   содержать в названии контекст, в котором на приложение будет оказан побочный эффект. Прим.: index.php - файл индекса, инициализирующий приложение.

```
Filename: index.php
```
```php
    // Предположим существование класса инициализации нашего приложения.
    include 'Initializer.php';
    
    $init = new Initializer();
    
    $application = $init->create('http{s}://', 'techport.ru', [80, 443]);
    $application->run();
```

Имена, не вошедшие в одну из групп выше, считаются __НЕ СТАНДАРТНЫМИ__.

Предлагаю следующие требования для __НЕ СТАНДАРТНЫХ__ имен файлов:

* _ДОЛЖНЫ_  соответствовать SCREAMING_SNAKE_CASE нотации.
* _ДОЛЖНЫ_  содержать контекст, в котором применяется данный файл.

###[1][2] Пути

Для файлов __не определяющих__ PHP классов единого стандарта нет. 

Так как мы активно юзаем фреймворки в разработке, то:

* Требования разработчиков фреймворка _МОГУТ_ перекрывать общие стандарты. 
* Приоритет стандарта, диктуемого разработчиком фреймворка __ВСЕГДА ВЫШЕ__ общих стандартов разработки, за исключением отдельных случаев.
* Все конфликты наложения стандартов друг на друга мы разрешим.

Для каждого файла __определяющего__ PHP класс:

Большинство современных фреймворков юзают автозагрузчики для подгрузки используемых классов. Для определения пути к файлу с классом функция, которая висит и ждет сигнала "тут нету класса с этим именем", должна как-либо получить полностью определенное пространство имен этого класса. Основываясь на пространстве имен, функция транслирует его в путь к файлу.

По дефолту, __стандартизированное пространство имен__ представляет следующую структуру:

`\<разработчик>\<еще>\<несколько>\<пространств_имен>\<нужный_ресурс>`

Автозагрузчик транслирует пространство имен динамически/статически в путь к подгружаемому файлу класса:

`Linux: <базовая_директория_автозагрузки>/<еще>/<несколько>/<пространств_имен>/<нужный_ресурс>.php`

Требования:

* _ДОЛЖНЫ_ транслироваться в путь к файлу и обратно. Дополнительные требования к транслируемости указаны в пункте _"Пространства имен"_.
* _СЛЕДУЕТ_ в файлах дирректорий использовать символы соответствующие данному набору:`[a-zA-Z0-9_]`.

К примеру мы будем юзать адаптер `MySQL`, базовая директория автозагрузки `/home/wave/Techport/CodeStyle`:
```php
    // Подключили.
    use Phalcon\Db\Adapter\MySQL;

    // Подгрузилось. 
    // Linux: /home/wave/Techport/CodeStyle/Phalcon/Db/Adapter/MySQL.php
    $adapter = new MySQL( 
        // args ...
    );
```

##[2] Общие рекомендации к коду

Старайтесь укладывать свой код в ширину от 80 до 120 символов.

В одной строке _НЕ ДОЛЖНО_ быть более одного выражения.

```php
	// Плохо
	$variable_two = $variable_one ? $variable_three = $variable_one : $variable_two; 
	
	// Можно. Но проводится лишняя проверка и 1-2 лишних присвоения.
	$variable_two 	= $variable_one ?: $variable_two;
	$variable_three = $variable_one ?: $variable_three;
	
	// Хорошо
    if ($variable_one) {
        $variable_three = $variable_two = $variable_one;
    }
```

Старайтесь включать в код пустые строки, если это способствует повышению удобочитаемости. Например, при разделении кода на логические блоки.

```php
    /**
	 * Checks, is remote user an our office user
	 * and returns true if it's true, otherwise - false.
	 *
	 * @return bool
	 */
	protected function isOffice()
	{
		$isOffice = self::$_isOfficeIPAddr;

		if (null !== $isOffice) {
			return $isOffice;
		}

		if ($clientIPA = $this->clientIP()) {
			$IPAddressList = $this->config['kloak']['filter'];

			if (is_string($IPAddressList)) {
				// Address list is nothing more than PCRE expression,
				// so - apply it to a remote address.
				$isOffice = preg_match($IPAddressList, $clientIPA);
			}
		}

		self::$_isOfficeIPAddr = $isOffice = (bool) $isOffice ?: false;

		return $isOffice;
	}
```

Для оформления отступов _СЛЕДУЕТ_ использовать четыре пробела, а не знак табуляции. Любая хорошая IDE позволит настроить замену табуляции на соответствующее количество пробелов. 

Ключевые слова `true`, `false` и `null` _ДОЛЖНЫ_ быть написаны в нижнем регистре.

##[3] Пространства имен

Полный путь к пространству имен _СЛЕДУЕТ_ начинать с пространства имён высшего уровня, указывающего на разработчика подгружаемого кода («имя производителя»).
```php
    // Разработчик: wave
    namespace wave\Any\Develop;

    // Разработчик: Phalcon
    use \Phalcon\Cache\Frontend\Output;
    use \Phalcon\Assets\Resource;   
```

Полный путь к пространству имен _МОЖЕТ_ включать в себя любое количество вложенных пространств имен. Но _СЛЕДУЕТ_ помнить об ограничениях файловых систем при интерпретации пространств имен в путь к файлу.
```php
    namespace <some_vendor>\Db\<any>\<namespace>\Mysql;
```

Во время преобразования пространств имен, разделители пространств имён преобразуется в разделитель имен каталогов соответствующей операционной системы.
```php    
    namespace Phalcon\Db\Adapter\Mysql;
    
    // После преобразования:
    // Windows: <root_directory>\Phalcon\Db\Adapter\Mysql.php
    // Linux:   <root_directory>/Phalcon/Db/Adapter/Mysql.php
```

Каждый символ "\_" (ASCII: 0x5F) в имени класса (Class\_Name) преобразуется в разделитель имен каталогов. При этом названия пространств имен с этим же символом остаются неизменными.
```php
    namespace Wave\Code_Style\RU\PHP_Lang;
    
    // После преобразования:
    // Windows: <root_directory>\Wave\Code_Style\RU\PHPLang.php
    // Linux:   <root_directory>/Wave/Code_Style/RU/PHPLang.php
```

При обращении к файловой системе полностью определённый путь к пространству имён и имя класса дополняются суффиксом `.php`. При использовании `require`, `require_once` стоит помнить, что не только имена файлов (Windows, Linux, OS X) могут включать точку (CodeStyle.php может оказаться директорией).

Если файл определяет пространство имен, в котором выполняется его код, пространство имен _ДОЛЖНО_ быть указано в самом начале файла после тэгов PHP. 

Перед определением и после определения пространства имен _ДОЛЖНА_ идти одна пустая строка.

```php
    <?php
    
    namespace wave\Document;
    
    // Код начинается здесь.
```

В случае, если файл __импортирует другие__ пространства имен:

* Импорт _ДОЛЖЕН_ начинаться после определения пространства имен (после `namespace ...`).
* Каждое импортируемое пространство имен _ДОЛЖНО_ быть указано на новой строке в виде: `use <пространство имен>;`.
* После каждого блока импорта _ДОЛЖНА_ быть одна пустая строка.

```php

    <?php
    
    namespace wave\Document;
    
    use \wave\ClassNames\StudlyCaps;
    use \wave\RepeatNamespaces as Repeat;

    use function \wave\Funcs\funcName;
    use function \wave\Funcs\anyOtherFunc;
    
    use const \wave\Constants\UNUSED;
    use const \wave\Constants\WANTED;

    class ClassName
    {
        // Код.
    }
```

##[4] Переменные

_ДОЛЖНЫ_ следовать одному из приведенных стилей именования: `camelCase`, `StudlyCaps`, `under_score`.

_ДОЛЖНЫ_ сохранять свой стиль именования на уровне обособленного участка кода, метода, класса, пакета, производителя, приложения.

_ДОЛЖНЫ_ сохранять стиль именования чужого кода. Если стиль именования чужого кода можно назвать __не стандартным__ (__не__ `camelCase`, `StudlyCaps`, `under_score`) вы _НЕ ДОЛЖНЫ_ следовать этому пункту на уровне кода этого производителя.

Имена переменных _НЕ ДОЛЖНЫ_ содержать транслитераций: `$transliteraciya = false;`.

Определение массива _ДОЛЖНО_ использовать синтаксис квадратных скобок `[]`, а не конструкции `array()`.

В статически определенных массивах с большим количеством элементов _СЛЕДУЕТ_ производить выравнивание по количеству элементов:
```php
	// Плохо. Тяжело найти и быстро изменить элемент. 
	$staticArray = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47 ];
	
	// Лучше. Но все еще занимает много места и имеет проблемы с отступами.
	$staticArray = [
					1, 2, 3, 4, 5,
					6, 7, 8, 9, 10,
					11, 12, 13, 14, 15,
					16, 17, 18, 19, 20,
					21, 22, 23, 24, 25,
					26, 27, 28, 29, 30,
					31, 32, 33, 34, 35,
					36, 37, 38, 39, 40,
					41, 42, 43, 44, 45,
					46, 47
					];
	
	// Хорошо. И выглядит уже не так массивно.
	$staticArray = [
		1, 2, 3, 4, 5,
		6, 7, 8, 9, 10,
		11, 12, 13, 14, 15,
		16, 17, 18, 19, 20,
		21, 22, 23, 24, 25,
		26, 27, 28, 29, 30,
		31, 32, 33, 34, 35,
		36, 37, 38, 39, 40,
		41, 42, 43, 44, 45,
		46, 47
	];
```

##[5] Константы

Имя константы _ДОЛЖНО_ следовать стилю `SCREAMING_SNAKE_CASE`.

Имена констант _НЕ ДОЛЖНЫ_ содержать транслитераций: `const TRANSLITERACIYA = false;`.

##[6] Управляющие конструкции

> После ключевого слова, определяющего управляющую конструкцию, _ДОЛЖЕН_ быть один пробел.

> После открывающих круглых скобок _НЕ ДОЛЖНО_ быть пробелов.

> Перед закрывающими круглыми скобками _НЕ ДОЛЖНО_ быть пробелов.

> Между закрывающей круглой скобкой и открывающей фигурной скобкой _ДОЛЖЕН_ быть один пробел.

> Тело конструкции _ДОЛЖНО_ быть дополнено одним отступом (четырьмя пробелами).

> Закрывающая фигурная скобка _ДОЛЖНА_ располагаться на следующей строке после тела конструкции.

> Тело каждой управляющей конструкции _ДОЛЖНО_ быть заключено в фигурные скобки. Это позволяет стандартизировать внешний вид управляющих конструкций и снизить риск возникновения ошибок при добавлении новых строк в тело конструкции.

> Конструкция if выглядит следующим образом. Обратите внимание на круглые скобки, пробелы и фигурные скобки, а также на тот факт, что слова else и elseif располагаются в той же строке, что и закрывающая фигурная скобка предшествующего тела конструкции.

```php
	if ($expr1) {
		// code ...
	} elseif ($expr2) {
		// code ...
	} else {
		// code ...
	}
```

> Ключевое слово elseif _СЛЕДУЕТ_ использовать вместо отдельного сочетания else и if. Так конструкция будет представлять собой одно слово.

> Конструкция switch выглядит следующим образом. Обратите внимание на круглые скобки, пробелы и фигурные скобки. Выражение case _ДОЛЖНО_ быть смещено на один отступ (четыре пробела) от switch, а ключевое слово break (или иное слово, обозначающее выход из конструкции) _ДОЛЖНО_ располагаться на том же уровне отступов, что и тело case. В том случае, когда в непустом теле case умышленно не используется break, _ДОЛЖЕН_ быть комментарий в стиле `// no break`.

```php
	switch ($expr) {
		case 0:
		echo 'First case, with a break';
		break;

		case 1:
		echo 'Second case, which falls through';
		// no break
		case 2:
		case 3:
		case 4:
		echo 'Third case, return instead of break';
		return;

		default:
		echo 'Default case';
		break;
	}
```

> Конструкция while выглядит следующим образом. Обратите внимание на круглые скобки, пробелы и фигурные скобки.

```php
	while ($expr) {
		// code ...
	}
```

> Соответственно, конструкция do while выглядит следующим образом. Обратите внимание на круглые скобки, пробелы и фигурные скобки.

```php
	do {
		// code ...
	} while ($expr);
```

> Конструкция for выглядит следующим образом. Обратите внимание на круглые скобки, пробелы и фигурные скобки.

```php
	for ($i = 0; $i < 10; $i++) {
		// code ...
	}
```

> Конструкция foreach выглядит следующим образом. Обратите внимание на круглые скобки, пробелы и фигурные скобки.

```php
	foreach ($iterable as $key => $value) {
		// code...
	}
```

> Блоки конструкции try catch выглядят следующим образом. Обратите внимание на круглые скобки, пробелы и фигурные скобки.

```php
	try {
		// code...
	} catch (FirstExceptionType $e) {
		// code...
	} catch (OtherExceptionType $e) {
		// code...
	}
```

##[7] Функции вне класса

До/после определения функции _ДОЛЖНА_ быть одна пустая строка.

В именовании функции должна использоваться нотация `under_score`.

Между названием функции и списком принимаемых аргументов _НЕ ДОЛЖНО_ быть пробела.

Открывающая скобка тела функции _ДОЛЖНА_ начинаться на новой строке после списка аргументов функции.

Закрывающая скобка тела функции _ДОЛЖНА_ начинаться на следующей после тела функции строке.

Тело функции должно быть смещено вправо на один отступ (4 пробела).

> В списке аргументов _НЕ ДОЛЖНО_ быть пробела перед запятыми, но _ДОЛЖЕН_ быть пробел после каждой запятой. 

> Аргументы со значениями по умолчанию _ДОЛЖНЫ_ располагаться в конце списка (после аргументов без значений по умолчанию).

_НЕ ДОЛЖНО_ быть пробелов вокруг скобок списка аргументов.

```php

	/**
	 * Внеклассовая функция.
	 */
	function function_name($argument_one, $argument_two, $argument_three = 0) 
	{
		return $argument_one + $argument_two + $argument_three;
	}
```

> Список аргументов _МОЖЕТ_ быть разделён на несколько строк, каждая из которых дополнена слева одним отступом (четырьмя пробелами). В таком случае первый элемент списка аргументов _ДОЛЖЕН_ начинаться с новой строки, и в каждой строке _ДОЛЖЕН_ быть указан только один аргумент.

> В случае, если список аргументов разделён на несколько строк, закрывающая круглая скобка и открывающая фигурная скобка _ДОЛЖНЫ_ располагаться вместе на своей отдельной строке, а между ними должен быть один пробел.

Обратите внимание на проставленные отступы и положение фигурной скобки начинающей тело функции:

```php
	function function_name(
		$argument_one, 
		$argument_two, 
		$argument_three = 0
	) {
		return $argument_one + $argument_two + $argument_three;
	}
```

Вызов функции выглядит следующим образом:

```php
	function_name($argument_one, $argument_two, $argument_three);
```

Вызов функции с множеством аргументов _СЛЕДУЕТ_ оформлять следующим образом. Обратите внимание на отступы:

```php
	function_name(
		$argument_one, 
		$argument_two, 
		$argument_three,
		$argument_four,
		$argument_five
	);
```

#### Функции-замыкания:

При определении функции-замыкания список принимаемых аргументов и ключевое слово `function` разделяются пробелами.

Если при определении замыкания используется ключевое слово `use`, оно следует на той же строке после списка аргументов и _ДОЛЖНО_ быть обособлено одним пробелом справа и слева.

При перечислении аргументов замыкания и элементов используемых в замыкании _НЕ ДОЛЖНО_ быть пробелов перед запятой и _ДОЛЖЕН_ быть один пробел после запятой.

Вокруг скобок, определяющих аргументы и используемые элементы замыкания _НЕ ДОЛЖНО_ быть пробелов.

Открывающая фигурная скобка определяющая начало тела замыкания, должна находиться на той же строке, где определены {аргументы|используемые элементы} замыкания, а закрывающая - на следующей строке после тела замыкания. 

> Аргументы замыкания со значениями по умолчанию _ДОЛЖНЫ_ располагаться в конце списка (после аргументов без значений по умолчанию). 

Описание замыкания выглядит следующим образом. Обратите внимание на круглые скобки, запятые, пробелы и фигурные скобки.

```php
	$closure = function ($first, $second, $variable = 0) {
		return $first + $second + $variable;
	};

	$closure = function ($first, $second, $variable = 0) use ($eOne, $eTwo) {
		return $first + $second + $variable + $eOne + $eTwo;
	};
```

> Список аргументов и переменных _МОЖЕТ_ быть разделён на несколько строк, каждая из которых дополнена слева одним отступом (четырьмя пробелами). В таком случае первый элемент списка _ДОЛЖЕН_ начинаться с новой строки, и в каждой строке _ДОЛЖЕН_ быть указан только один элемент.

> Когда последний список (аргументов или переменных) разделён на несколько строк, закрывающая круглая скобка и открывающая фигурная скобка _ДОЛЖНЫ_ располагаться на одной строке и быть разделены одним пробелом.

Ниже - примеры замыканий в разных вариациях их определения.

```php
	$closure = function (
		$first,
		$second,
		$third
	) {
		return true;
	};

	$closure = function () use (
		$eOne,
		$eTwo,
		$eThree
	) {
		return true;
	};

	$closure = function (
		$first,
		$second,
		$third
	) use (
		$eOne,
		$eTwo,
		$eThree
	) {
		return true;
	};
	
	$this->closureInFunctionCall(
		$anyArgument,
		function ($first) use ($eOne) {
			return true;
		},
		$anyOtherArgument
	);
```

##[8] Классы
###[8][0] Определение классов

Имена классов _ДОЛЖНЫ_ быть написаны в `StudlyCaps` нотации. 

Фигурная скобка, открывающая тело класса _ДОЛЖНА_ начинаться на следующей строке после объявления имени {класса|родителя|подключаемых интерфейсов}, а закрывающая - на следующей строке после тела класса.

Тело класса _ДОЛЖНО_ содержать один отступ (4 пробела) относительно фигурных скобок тела класса.

> Ключевые слова extends и implements _ДОЛЖНЫ_ находиться на той же строке, на которой находится имя класса.

```php
	namespace Wave\Document;

	use \Wave\ClassNames\StudlyCaps;
	use \Wave\RepeatNamespaces as Repeat;

	class CodeStyle extends Document implements Repeat
	{
	 	// code ...
	}
```

> Список реализуемых интерфейсов _МОЖЕТ_ быть разделён на несколько строк, каждая из которых дополнена слева одним отступом (четырьмя пробелами). В таком случае первый элемент списка интерфейсов _ДОЛЖЕН_ начинаться с новой строки, и в каждой строке _ДОЛЖЕН_ быть указан только один интерфейс.

```php
	class CodeStyle extends Document implements 
		\Repeat
		\Wave\NextInterface
		\Port\AnotherInterface
	{
		// code ...
	}
```

###[8][1] Константы

Константы класса перенимают __ВСЕ__ общие требования, применяемые к константам.

_ДОЛЖНЫ_ быть определены в начале тела класса.

```php
  class Constants
  {
       const VENDOR = 'Techport';
	   
	   const AUTHOR = 'Vadim Kharitonovich';
  }
```

###[8][2] Свойства и методы

#### Общее:
Для каждого область видимости _ДОЛЖНА_ быть указана явно. Это позволяет избежать проблем с изменением правил интерпретации пустых полей области видимости при объявлении свойств и методов. 

Одиночный знак подчёркивания в начале имени _НЕ СЛЕДУЕТ_ интерпретировать как признак защищённой (protected) или приватной (private) области видимости, но это _МОЖНО_ использовать.

```php
	class CodeStyle
	{
		public $propertyOne;

		// Нижнее подчеркивание не обязательно
		protected $_propertyTwo; 

		// Нижнее подчеркивание не обязательно
		private $_propertyThree; 

		// Нижнее подчеркивание не обязательно
		protected function $_protectedMethod()
		{
			return true;
		}
	}
```

> Ключевые слова abstract и final, в случае их наличия, _ДОЛЖНЫ_ располагаться перед указанием области видимости.

```php
	class AbstractFinal
	{
		public $simpleProperty;
		
		abstract public $abstractProperty;
		
		final public function $finalMethod()
		{
			return true;
		}
	}
```

> Ключевое слово static, в случае его наличия, _ДОЛЖНО_ располагаться после указания области видимости.

```php
	class Any
	{
		final public statuc function $finalMethod()
		{
			return true;
		}
	}
```

#### Свойства:
При определении свойства _НЕ ДОЛЖНО_ применяться ключевое слово `var`.

> В одном выражении _НЕ ДОЛЖНО_ быть определено более одного свойства.

#### Методы:
При определении методов, все методы перенимают требования предъявленные к определению функций, за исключением: именования и применяемой области видимости.

Имена методов _ДОЛЖНЫ_ следовать нотации `camelCase`.

```php
	class MethodNotations extends Notations implements NotationInterface
	{
		protected $notation = 'camelCase';
		
		public function getNotation() 
		{
			return $this->notation;
		}
	}
```

##[9] На этом конец

Все предложения по модификации кодстайла, обнаруженным ошибкам обязательно отправляйте! Ниже указаны мои контакты.

__Для связи с автором:__

```ruby
[ICQ-UIN]	674009118
[e-mail]	ev4wport@gmail.com
```
##[9][0] Используемые ресурсы

__Спасибо переводчику за готовые цитаты:__
http://svyatoslav.biz/misc/psr_translation/

__Стандарты оформления кода:__
http://www.php-fig.org/psr/psr-1/
http://www.php-fig.org/psr/psr-2/

__Стандарты автозагрузки:__
http://www.php-fig.org/psr/psr-0/
http://www.php-fig.org/psr/psr-4/

